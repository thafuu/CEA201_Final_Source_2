<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CEA201 FA24 RE Quiz - Student ID: 306561</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .quiz-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .quiz-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .quiz-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .quiz-header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .score-summary {
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .score-item {
            text-align: center;
        }

        .score-number {
            font-size: 1.5em;
            font-weight: bold;
        }

        .score-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .quiz-content {
            padding: 40px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .question-item {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .question-item.answered {
            border-color: #28a745;
            background: #f8fff9;
        }

        .question-item.incorrect {
            border-color: #dc3545;
            background: #fff8f8;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .question-status {
            font-size: 1.2em;
        }

        .question-text {
            font-size: 1.1em;
            margin-bottom: 20px;
            color: #333;
            line-height: 1.5;
            font-weight: 500;
        }

        .options-container {
            margin-bottom: 15px;
        }

        .option-item {
            display: flex;
            align-items: center;
            background: white;
            margin: 8px 0;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option-item:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .option-item.selected {
            border-color: #667eea;
            background: #e3f2fd;
        }

        .option-item.correct {
            border-color: #28a745;
            background: #d4edda;
            color: #155724;
            font-weight: bold;
        }

        .option-item.incorrect {
            border-color: #dc3545;
            background: #f8d7da;
            color: #721c24;
        }

        .option-item.user-selected {
            border-color: #007bff;
            background: #cce7ff;
            font-weight: bold;
        }

        .option-item.user-incorrect {
            border-color: #dc3545;
            background: #f8d7da;
            color: #721c24;
            text-decoration: line-through;
        }

        .answer-indicator {
            margin-left: 10px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .correct-indicator {
            color: #28a745;
        }

        .incorrect-indicator {
            color: #dc3545;
        }

        .explanation {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .explanation.show {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .explanation h4 {
            color: #856404;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            font-size: 1em;
        }

        .explanation p {
            color: #533f04;
            line-height: 1.5;
            margin: 0;
        }

        .action-buttons {
            position: sticky;
            bottom: 0;
            background: white;
            padding: 20px 40px;
            border-top: 2px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .icon {
            margin-right: 8px;
        }

        /* Scrollbar styling */
        .quiz-content::-webkit-scrollbar {
            width: 8px;
        }

        .quiz-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .quiz-content::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .quiz-content::-webkit-scrollbar-thumb:hover {
            background: #5a6fd8;
        }
    </style>
</head>
<body>
    <div class="quiz-container">
        <div class="quiz-header">
            <h1>üñ•Ô∏è CEA201 FA24 RE Quiz</h1>
            <p>Computer Architecture - Student ID: 306561</p>
            <div class="score-summary">
                <div class="score-item">
                    <div class="score-number" id="totalQuestions">25</div>
                    <div class="score-label">T·ªïng c√¢u</div>
                </div>
                <div class="score-item">
                    <div class="score-number" id="answeredCount">0</div>
                    <div class="score-label">ƒê√£ tr·∫£ l·ªùi</div>
                </div>
                <div class="score-item">
                    <div class="score-number" id="correctCount">0</div>
                    <div class="score-label">ƒê√∫ng</div>
                </div>
                <div class="score-item">
                    <div class="score-number" id="scorePercentage">0%</div>
                    <div class="score-label">ƒêi·ªÉm s·ªë</div>
                </div>
            </div>
        </div>

        <div class="quiz-content" id="quizContent">
            <!-- Questions will be dynamically generated here -->
        </div>

        <div class="action-buttons">
            <button class="btn btn-secondary" onclick="resetQuiz()">
                üîÑ L√†m l·∫°i to√†n b·ªô
            </button>
            <div>
                <button class="btn btn-primary" onclick="showAllAnswers()">
                    üëÅÔ∏è Hi·ªán t·∫•t c·∫£ ƒë√°p √°n
                </button>
                <button class="btn btn-success" onclick="checkAllAnswers()">
                    ‚úÖ Ki·ªÉm tra k·∫øt qu·∫£
                </button>
            </div>
        </div>
    </div>

    <script>
        const questions = [
            {
                id: 1,
                question: "What is the correct order of memory access speed from fastest to slowest?",
                options: [
                    "Registers > Cache > RAM > SSD",
                    "Cache > Registers > RAM > SSD", 
                    "Registers > Cache > SSD > RAM",
                    "Cache > Registers > SSD > RAM"
                ],
                correct: 0,
                type: "single",
                explanation: "Th·ª© t·ª± t·ªëc ƒë·ªô truy c·∫≠p b·ªô nh·ªõ t·ª´ nhanh ƒë·∫øn ch·∫≠m: Register > Cache > RAM > SSD. Thanh ghi (Register) nhanh nh·∫•t, SSD ch·∫≠m nh·∫•t."
            },
            {
                id: 2,
                question: "Choose the most basic four functions of a computer:",
                options: [
                    "Moving data, storing data, processing data, controlling",
                    "Reading data, writing data, executing programs, managing files",
                    "Input, output, processing, storage", 
                    "Calculation, comparison, data transfer, program control"
                ],
                correct: 0,
                type: "single",
                explanation: "M√°y t√≠nh th·ª±c hi·ªán 4 ch·ª©c nƒÉng c∆° b·∫£n: Di chuy·ªÉn d·ªØ li·ªáu (Moving data), L∆∞u tr·ªØ d·ªØ li·ªáu (Storing data), X·ª≠ l√Ω d·ªØ li·ªáu (Processing data), ƒêi·ªÅu khi·ªÉn (Controlling)."
            },
            {
                id: 3,
                question: "In the von Neumann architecture, what are stored together in the same memory?",
                options: [
                    "Data and instructions",
                    "Programs and operating system",
                    "Input and output data",
                    "Cache and main memory"
                ],
                correct: 0,
                type: "single",
                explanation: "Ki·∫øn tr√∫c von Neumann ƒë·∫∑c tr∆∞ng b·ªüi vi·ªác l∆∞u tr·ªØ c·∫£ d·ªØ li·ªáu v√† l·ªánh trong c√πng m·ªôt b·ªô nh·ªõ, kh√°c v·ªõi ki·∫øn tr√∫c Harvard c√≥ b·ªô nh·ªõ ri√™ng bi·ªát."
            },
            {
                id: 4,
                question: "What is the function of the Control Unit (CU) in a processor?",
                options: [
                    "Performs arithmetic and logical operations",
                    "Stores data and instructions temporarily",
                    "Directs the operation of other CPU components",
                    "Interfaces with external devices"
                ],
                correct: 2,
                type: "single",
                explanation: "CU (Control Unit) c√≥ ch·ª©c nƒÉng ƒëi·ªÅu khi·ªÉn ho·∫°t ƒë·ªông c·ªßa t·∫•t c·∫£ c√°c th√†nh ph·∫ßn kh√°c trong CPU, ƒë·∫£m b·∫£o c√°c l·ªánh ƒë∆∞·ª£c th·ª±c hi·ªán ƒë√∫ng tr√¨nh t·ª±."
            },
            {
                id: 5,
                question: "Which generation of computers used vacuum tubes?",
                options: [
                    "First generation",
                    "Second generation", 
                    "Third generation",
                    "Fourth generation"
                ],
                correct: 0,
                type: "single",
                explanation: "Th·∫ø h·ªá m√°y t√≠nh ƒë·∫ßu ti√™n (1940s-1950s) s·ª≠ d·ª•ng ƒë√®n ch√¢n kh√¥ng (vacuum tubes). C√°c th·∫ø h·ªá sau s·ª≠ d·ª•ng transistor, IC, v√† vi x·ª≠ l√Ω."
            },
            {
                id: 6,
                question: "What does MAR (Memory Address Register) contain?",
                options: [
                    "The data to be written to memory",
                    "The address of the memory location to be accessed",
                    "The instruction being executed",
                    "The status of memory operations"
                ],
                correct: 1,
                type: "single",
                explanation: "MAR (Memory Address Register) ch·ª©a ƒë·ªãa ch·ªâ c·ªßa v·ªã tr√≠ b·ªô nh·ªõ c·∫ßn ƒë∆∞·ª£c truy c·∫≠p ƒë·ªÉ ƒë·ªçc ho·∫∑c ghi d·ªØ li·ªáu."
            },
            {
                id: 7,
                question: "Which of the following are categories of external devices? (Select all correct answers)",
                options: [
                    "Human readable",
                    "Machine readable", 
                    "Communication devices",
                    "Processing devices"
                ],
                correct: [0, 1, 2],
                type: "multiple",
                explanation: "C√°c thi·∫øt b·ªã ngo·∫°i vi ƒë∆∞·ª£c ph√¢n th√†nh 3 nh√≥m: Human readable (m√†n h√¨nh, b√†n ph√≠m), Machine readable (c·∫£m bi·∫øn, scanner), Communication devices (card m·∫°ng, modem)."
            },
            {
                id: 8,
                question: "What is the maximum addressable memory of a processor with 24-bit address bus?",
                options: [
                    "16 MB",
                    "24 MB",
                    "32 MB", 
                    "64 MB"
                ],
                correct: 0,
                type: "single",
                explanation: "V·ªõi 24-bit address bus: 2^24 = 16,777,216 bytes = 16 MB. C√¥ng th·ª©c: 2^(s·ªë bit ƒë·ªãa ch·ªâ) ƒë·ªÉ t√≠nh dung l∆∞·ª£ng t·ªëi ƒëa."
            },
            {
                id: 9,
                question: "What interprets instructions in memory and causes them to be executed?",
                options: [
                    "ALU (Arithmetic Logic Unit)",
                    "Control Unit (CU)",
                    "Memory Management Unit",
                    "Input/Output Controller"
                ],
                correct: 1,
                type: "single",
                explanation: "Control Unit (CU) c√≥ nhi·ªám v·ª• di·ªÖn gi·∫£i c√°c l·ªánh trong b·ªô nh·ªõ v√† ƒëi·ªÅu khi·ªÉn vi·ªác th·ª±c thi ch√∫ng."
            },
            {
                id: 10,
                question: "What is the main characteristic of a Synchronous Bus?",
                options: [
                    "Operations are controlled by a clock signal",
                    "No timing constraints on operations",
                    "Faster than asynchronous bus",
                    "Uses fewer control lines"
                ],
                correct: 0,
                type: "single",
                explanation: "Synchronous Bus ƒë·∫∑c tr∆∞ng b·ªüi vi·ªác t·∫•t c·∫£ c√°c ho·∫°t ƒë·ªông ƒë∆∞·ª£c ƒëi·ªÅu khi·ªÉn b·ªüi t√≠n hi·ªáu xung nh·ªãp (clock signal)."
            },
            {
                id: 11,
                question: "What is the main advantage of cache memory?",
                options: [
                    "Larger storage capacity",
                    "Lower cost per bit",
                    "Faster access time than main memory",
                    "Non-volatile storage"
                ],
                correct: 2,
                type: "single",
                explanation: "Cache memory c√≥ th·ªùi gian truy c·∫≠p nhanh h∆°n nhi·ªÅu so v·ªõi main memory (RAM), gi√∫p tƒÉng hi·ªáu su·∫•t h·ªá th·ªëng."
            },
            {
                id: 12,
                question: "In direct mapping cache, how many bits are needed for the TAG field with 256MB main memory and 512KB cache?",
                options: [
                    "8 bits",
                    "9 bits", 
                    "10 bits",
                    "11 bits"
                ],
                correct: 1,
                type: "single",
                explanation: "V·ªõi 256MB main memory (28 bits) v√† 512KB cache (19 bits), TAG field c·∫ßn 28-19 = 9 bits trong direct mapping."
            },
            {
                id: 13,
                question: "How many check bits are required for Single Error Correction (SEC) of 8-bit data?",
                options: [
                    "3 bits",
                    "4 bits",
                    "5 bits", 
                    "6 bits"
                ],
                correct: 1,
                type: "single",
                explanation: "ƒê·ªÉ s·ª≠a l·ªói 1-bit trong d·ªØ li·ªáu 8-bit, c·∫ßn 4 check bits theo c√¥ng th·ª©c Hamming code: 2^4 ‚â• 8+4+1."
            },
            {
                id: 14,
                question: "What is the correct order of storage technologies from lowest to highest performance?",
                options: [
                    "Hard Disk ‚Üí NAND Flash ‚Üí DRAM ‚Üí SRAM",
                    "NAND Flash ‚Üí Hard Disk ‚Üí DRAM ‚Üí SRAM",
                    "Hard Disk ‚Üí DRAM ‚Üí NAND Flash ‚Üí SRAM",
                    "SRAM ‚Üí DRAM ‚Üí NAND Flash ‚Üí Hard Disk"
                ],
                correct: 0,
                type: "single",
                explanation: "Th·ª© t·ª± hi·ªáu su·∫•t t·ª´ th·∫•p ƒë·∫øn cao: Hard Disk ‚Üí NAND Flash ‚Üí DRAM ‚Üí SRAM"
            },
            {
                id: 15,
                question: "In hard disk terminology, what is a cylinder?",
                options: [
                    "A single track on one platter",
                    "The set of all tracks at the same relative position on all platters",
                    "The gap between tracks",
                    "A section of a track"
                ],
                correct: 1,
                type: "single",
                explanation: "Cylinder l√† t·∫≠p h·ª£p t·∫•t c·∫£ c√°c track ·ªü c√πng v·ªã tr√≠ t∆∞∆°ng ƒë·ªëi tr√™n t·∫•t c·∫£ c√°c ƒëƒ©a (platters) trong ·ªï c·ª©ng."
            },
            {
                id: 16,
                question: "Which RAID level uses striping with parity and requires minimum 3 disks?",
                options: [
                    "RAID 0",
                    "RAID 1", 
                    "RAID 3",
                    "RAID 5"
                ],
                correct: 2,
                type: "single",
                explanation: "RAID 3 s·ª≠ d·ª•ng k·ªπ thu·∫≠t striping v·ªõi parity bit v√† y√™u c·∫ßu t·ªëi thi·ªÉu 3 ƒëƒ©a ƒë·ªÉ ho·∫°t ƒë·ªông."
            },
            {
                id: 17,
                question: "What is the main performance advantage of SSD over magnetic disk?",
                options: [
                    "Lower cost per gigabyte",
                    "Larger storage capacity",
                    "Faster access time and lower latency",
                    "Better data compression"
                ],
                correct: 2,
                type: "single",
                explanation: "SSD c√≥ th·ªùi gian truy c·∫≠p nhanh h∆°n v√† ƒë·ªô tr·ªÖ th·∫•p h∆°n ƒë√°ng k·ªÉ so v·ªõi ·ªï ƒëƒ©a t·ª´ t√≠nh (HDD)."
            },
            {
                id: 18,
                question: "According to De Morgan's theorem, NOT(A OR B) equals:",
                options: [
                    "NOT A AND NOT B",
                    "NOT A OR NOT B",
                    "A AND B",
                    "A OR B"
                ],
                correct: 0,
                type: "single",
                explanation: "ƒê·ªãnh l√Ω De Morgan: NOT(A OR B) = NOT A AND NOT B. Ph·ªß ƒë·ªãnh c·ªßa OR l√† AND c·ªßa c√°c ph·ªß ƒë·ªãnh."
            },
            {
                id: 19,
                question: "What is an interrupt vector?",
                options: [
                    "A signal sent by I/O device to CPU",
                    "A memory location containing interrupt handler addresses", 
                    "A register storing interrupt status",
                    "A type of interrupt priority"
                ],
                correct: 1,
                type: "single",
                explanation: "Interrupt vector l√† v√πng b·ªô nh·ªõ ch·ª©a ƒë·ªãa ch·ªâ c·ªßa c√°c interrupt handlers, gi√∫p CPU x√°c ƒë·ªãnh tr√¨nh x·ª≠ l√Ω ng·∫Øt ph√π h·ª£p."
            },
            {
                id: 20,
                question: "In instruction execution, what does 'Operand Address Calculation' involve?",
                options: [
                    "Computing the result of an operation",
                    "Determining the memory address of an operand",
                    "Fetching the instruction from memory",
                    "Storing the result back to memory"
                ],
                correct: 1,
                type: "single",
                explanation: "Operand Address Calculation l√† qu√° tr√¨nh x√°c ƒë·ªãnh ƒë·ªãa ch·ªâ b·ªô nh·ªõ c·ªßa to√°n h·∫°ng c·∫ßn thi·∫øt cho l·ªánh."
            },
            {
                id: 21,
                question: "What role does an API (Application Programming Interface) play?",
                options: [
                    "Allows programs to access hardware using high-level libraries",
                    "Defines machine language instructions",
                    "Manages memory allocation",
                    "Controls interrupt handling"
                ],
                correct: 0,
                type: "single",
                explanation: "API cho ph√©p c√°c ch∆∞∆°ng tr√¨nh truy c·∫≠p t√†i nguy√™n ph·∫ßn c·ª©ng th√¥ng qua c√°c th∆∞ vi·ªán ng√¥n ng·ªØ b·∫≠c cao."
            },
            {
                id: 22,
                question: "What is the initial state of a newly created process?",
                options: [
                    "Ready",
                    "Running",
                    "New", 
                    "Waiting"
                ],
                correct: 2,
                type: "single",
                explanation: "Khi m·ªôt ti·∫øn tr√¨nh m·ªõi ƒë∆∞·ª£c t·∫°o, n√≥ b·∫Øt ƒë·∫ßu ·ªü tr·∫°ng th√°i 'New' tr∆∞·ªõc khi chuy·ªÉn sang 'Ready' ƒë·ªÉ ch·ªù CPU."
            },
            {
                id: 23,
                question: "Which statement about TLB (Translation Lookaside Buffer) is INCORRECT?",
                options: [
                    "TLB eliminates the need for page tables in memory",
                    "TLB stores recent virtual-to-physical address translations",
                    "TLB miss requires accessing the page table",
                    "TLB is a cache for address translations"
                ],
                correct: 0,
                type: "single",
                explanation: "‚ùå TLB kh√¥ng lo·∫°i b·ªè nhu c·∫ßu v·ªÅ page table, m√† ch·ªâ l√† cache gi√∫p truy c·∫≠p page table nhanh h∆°n."
            },
            {
                id: 24,
                question: "How does Boolean algebra help in digital circuit design?",
                options: [
                    "It simplifies the implementation of logical functions",
                    "It increases circuit complexity",
                    "It reduces power consumption",
                    "It improves signal quality"
                ],
                correct: 0,
                type: "single",
                explanation: "Boolean algebra gi√∫p ƒë∆°n gi·∫£n h√≥a vi·ªác thi·∫øt k·∫ø v√† tri·ªÉn khai c√°c h√†m logic trong m·∫°ch s·ªë."
            },
            {
                id: 25,
                question: "What is the output of a NAND gate when both inputs are 1?",
                options: [
                    "0",
                    "1",
                    "Undefined",
                    "High impedance"
                ],
                correct: 0,
                type: "single",
                explanation: "NAND gate v·ªõi c·∫£ hai ƒë·∫ßu v√†o l√† 1 s·∫Ω cho ƒë·∫ßu ra l√† 0. NAND = NOT AND, n√™n NOT(1 AND 1) = NOT(1) = 0."
            }
        ];

        let userAnswers = {};
        let showingAnswers = false;

        function initQuiz() {
            renderAllQuestions();
            updateScoreSummary();
        }

        function renderAllQuestions() {
            const quizContent = document.getElementById('quizContent');
            
            quizContent.innerHTML = questions.map(question => `
                <div class="question-item" id="question-${question.id}">
                    <div class="question-header">
                        <div class="question-number">C√¢u ${question.id}</div>
                        <div class="question-status" id="status-${question.id}">‚ùì</div>
                    </div>
                    
                    <div class="question-text">${question.question}</div>
                    
                    <div class="options-container">
                        ${question.options.map((option, index) => `
                            <div class="option-item" onclick="selectOption(${question.id}, ${index})">
                                ${question.type === 'multiple' ? 
                                    `<input type="checkbox" class="option-checkbox" id="q${question.id}-opt${index}" onchange="selectOption(${question.id}, ${index})">` :
                                    `<input type="radio" name="q${question.id}" class="option-radio" id="q${question.id}-opt${index}" onchange="selectOption(${question.id}, ${index})">`
                                }
                                <label class="option-text" for="q${question.id}-opt${index}">
                                    ${String.fromCharCode(65 + index)}. ${option}
                                </label>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="explanation" id="explanation-${question.id}">
                        <h4><span class="icon">üí°</span>Gi·∫£i th√≠ch:</h4>
                        <p>${question.explanation}</p>
                    </div>
                </div>
            `).join('');
        }

        function selectOption(questionId, optionIndex) {
            const question = questions.find(q => q.id === questionId);
            const questionElement = document.getElementById(`question-${questionId}`);
            const optionElement = document.getElementById(`q${questionId}-opt${optionIndex}`);
            
            if (showingAnswers) return; // Prevent changes when answers are shown
            
            if (question.type === 'multiple') {
                // Handle multiple choice
                if (!userAnswers[questionId]) {
                    userAnswers[questionId] = [];
                }
                
                if (optionElement.checked) {
                    if (!userAnswers[questionId].includes(optionIndex)) {
                        userAnswers[questionId].push(optionIndex);
                    }
                } else {
                    userAnswers[questionId] = userAnswers[questionId].filter(idx => idx !== optionIndex);
                }
                
                // Check if user has selected the correct number of answers for multiple choice
                const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                if (userAnswers[questionId] && userAnswers[questionId].length === correctAnswers.length) {
                    showQuestionFeedback(questionId);
                } else {
                    hideQuestionFeedback(questionId);
                }
            } else {
                // Handle single choice
                userAnswers[questionId] = optionIndex;
                // Show feedback immediately for single choice
                showQuestionFeedback(questionId);
            }
            
            updateQuestionStatus(questionId);
            updateScoreSummary();
        }

        function showQuestionFeedback(questionId) {
            const question = questions.find(q => q.id === questionId);
            const explanationElement = document.getElementById(`explanation-${questionId}`);
            const isCorrect = checkAnswer(questionId);
            
            // Show explanation
            explanationElement.classList.add('show');
            
            // Update option styling to show correct/incorrect
            const optionElements = document.querySelectorAll(`[id^="q${questionId}-opt"]`);
            optionElements.forEach((element, index) => {
                const optionContainer = element.parentElement;
                optionContainer.classList.remove('correct', 'incorrect', 'user-selected', 'user-incorrect');
                
                // Remove existing indicators
                const existingIndicator = optionContainer.querySelector('.answer-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
                
                const userAnswer = userAnswers[questionId];
                const isUserSelection = question.type === 'multiple' ? 
                    (userAnswer && userAnswer.includes(index)) : 
                    (userAnswer === index);
                
                if (question.type === 'multiple') {
                    const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                    
                    if (correctAnswers.includes(index)) {
                        // This is a correct answer
                        optionContainer.classList.add('correct');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator correct-indicator';
                        indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng' : '‚úì ƒê√°p √°n ƒë√∫ng';
                        optionContainer.appendChild(indicator);
                    } else if (isUserSelection) {
                        // User selected wrong answer
                        optionContainer.classList.add('user-incorrect');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator incorrect-indicator';
                        indicator.textContent = '‚úó Sai';
                        optionContainer.appendChild(indicator);
                    }
                } else {
                    if (index === question.correct) {
                        // This is the correct answer
                        optionContainer.classList.add('correct');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator correct-indicator';
                        indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng' : '‚úì ƒê√°p √°n ƒë√∫ng';
                        optionContainer.appendChild(indicator);
                    } else if (isUserSelection) {
                        // User selected wrong answer
                        optionContainer.classList.add('user-incorrect');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator incorrect-indicator';
                        indicator.textContent = '‚úó Sai';
                        optionContainer.appendChild(indicator);
                    }
                }
            });
        }

        function hideQuestionFeedback(questionId) {
            const explanationElement = document.getElementById(`explanation-${questionId}`);
            explanationElement.classList.remove('show');
            
            // Remove feedback styling from options
            const optionElements = document.querySelectorAll(`[id^="q${questionId}-opt"]`);
            optionElements.forEach((element, index) => {
                const optionContainer = element.parentElement;
                optionContainer.classList.remove('correct', 'incorrect', 'user-selected', 'user-incorrect');
                
                // Remove existing indicators
                const existingIndicator = optionContainer.querySelector('.answer-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
            });
        }

        function updateQuestionStatus(questionId) {
            const question = questions.find(q => q.id === questionId);
            const statusElement = document.getElementById(`status-${questionId}`);
            const questionElement = document.getElementById(`question-${questionId}`);
            
            // Check if question is properly answered
            let isAnswered = false;
            if (question.type === 'multiple') {
                const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                isAnswered = userAnswers[questionId] && userAnswers[questionId].length === correctAnswers.length;
            } else {
                isAnswered = userAnswers[questionId] !== undefined;
            }
            
            if (isAnswered) {
                if (showingAnswers || hasQuestionFeedback(questionId)) {
                    const isCorrect = checkAnswer(questionId);
                    statusElement.textContent = isCorrect ? '‚úÖ' : '‚ùå';
                    questionElement.className = `question-item ${isCorrect ? 'answered' : 'incorrect'}`;
                } else {
                    statusElement.textContent = '‚úèÔ∏è';
                    questionElement.className = 'question-item answered';
                }
            } else {
                statusElement.textContent = '‚ùì';
                questionElement.className = 'question-item';
            }
        }

        function hasQuestionFeedback(questionId) {
            const explanationElement = document.getElementById(`explanation-${questionId}`);
            return explanationElement.classList.contains('show');
        }

        function checkAnswer(questionId) {
            const question = questions.find(q => q.id === questionId);
            const userAnswer = userAnswers[questionId];
            
            if (question.type === 'multiple') {
                if (!userAnswer || userAnswer.length === 0) return false;
                const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                return userAnswer.length === correctAnswers.length && 
                       userAnswer.every(ans => correctAnswers.includes(ans));
            } else {
                return userAnswer === question.correct;
            }
        }

        function updateScoreSummary() {
            const answeredCount = Object.keys(userAnswers).filter(qId => {
                const question = questions.find(q => q.id == qId);
                const answer = userAnswers[qId];
                return answer !== undefined && 
                       (question.type === 'single' || (question.type === 'multiple' && answer.length > 0));
            }).length;
            
            const correctCount = Object.keys(userAnswers).filter(qId => checkAnswer(parseInt(qId))).length;
            const percentage = answeredCount > 0 ? Math.round((correctCount / questions.length) * 100) : 0;
            
            document.getElementById('answeredCount').textContent = answeredCount;
            document.getElementById('correctCount').textContent = correctCount;
            document.getElementById('scorePercentage').textContent = percentage + '%';
        }

        function showAllAnswers() {
            showingAnswers = true;
            
            questions.forEach(question => {
                const explanationElement = document.getElementById(`explanation-${question.id}`);
                explanationElement.classList.add('show');
                
                // Highlight correct answers only
                const optionElements = document.querySelectorAll(`[id^="q${question.id}-opt"]`);
                optionElements.forEach((element, index) => {
                    const optionContainer = element.parentElement;
                    optionContainer.classList.remove('correct', 'incorrect', 'selected', 'user-selected', 'user-incorrect');
                    
                    // Remove existing indicators
                    const existingIndicator = optionContainer.querySelector('.answer-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }
                    
                    if (question.type === 'multiple') {
                        const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                        if (correctAnswers.includes(index)) {
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = '‚úì ƒê√∫ng';
                            optionContainer.appendChild(indicator);
                        }
                    } else {
                        if (index === question.correct) {
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = '‚úì ƒê√∫ng';
                            optionContainer.appendChild(indicator);
                        }
                    }
                    
                    // Disable further interactions
                    element.disabled = true;
                });
                
                updateQuestionStatus(question.id);
            });
            
            updateScoreSummary();
        }

        function checkAllAnswers() {
            showingAnswers = true;
            
            questions.forEach(question => {
                const explanationElement = document.getElementById(`explanation-${question.id}`);
                explanationElement.classList.add('show');
                
                // Show user answers vs correct answers
                const optionElements = document.querySelectorAll(`[id^="q${question.id}-opt"]`);
                optionElements.forEach((element, index) => {
                    const optionContainer = element.parentElement;
                    optionContainer.classList.remove('correct', 'incorrect', 'selected', 'user-selected', 'user-incorrect');
                    
                    // Remove existing indicators
                    const existingIndicator = optionContainer.querySelector('.answer-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }
                    
                    const userAnswer = userAnswers[question.id];
                    const isUserSelection = question.type === 'multiple' ? 
                        (userAnswer && userAnswer.includes(index)) : 
                        (userAnswer === index);
                    
                    if (question.type === 'multiple') {
                        const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                        
                        if (correctAnswers.includes(index)) {
                            // This is a correct answer
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng - B·∫°n ƒë√£ ch·ªçn' : '‚úì ƒê√°p √°n ƒë√∫ng';
                            optionContainer.appendChild(indicator);
                        } else if (isUserSelection) {
                            // User selected wrong answer
                            optionContainer.classList.add('user-incorrect');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator incorrect-indicator';
                            indicator.textContent = '‚úó Sai - B·∫°n ƒë√£ ch·ªçn';
                            optionContainer.appendChild(indicator);
                        }
                    } else {
                        if (index === question.correct) {
                            // This is the correct answer
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng - B·∫°n ƒë√£ ch·ªçn' : '‚úì ƒê√°p √°n ƒë√∫ng';
                            optionContainer.appendChild(indicator);
                        } else if (isUserSelection) {
                            // User selected wrong answer
                            optionContainer.classList.add('user-incorrect');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator incorrect-indicator';
                            indicator.textContent = '‚úó Sai - B·∫°n ƒë√£ ch·ªçn';
                            optionContainer.appendChild(indicator);
                        }
                    }
                    
                    // Disable further interactions
                    element.disabled = true;
                });
                
                updateQuestionStatus(question.id);
            });
            
            updateScoreSummary();
        }

        function resetQuiz() {
            userAnswers = {};
            showingAnswers = false;
            
            // Reset all form elements
            document.querySelectorAll('input[type="radio"], input[type="checkbox"]').forEach(input => {
                input.checked = false;
                input.disabled = false;
            });
            
            // Hide all explanations and feedback
            questions.forEach(question => {
                hideQuestionFeedback(question.id);
            });
            
            // Reset all option styling and remove indicators
            document.querySelectorAll('.option-item').forEach(option => {
                option.classList.remove('correct', 'incorrect', 'selected', 'user-selected', 'user-incorrect');
                const indicator = option.querySelector('.answer-indicator');
                if (indicator) {
                    indicator.remove();
                }
            });
            
            // Update all question statuses
            questions.forEach(question => {
                updateQuestionStatus(question.id);
            });
            
            updateScoreSummary();
        }

        // Initialize quiz when page loads
        document.addEventListener('DOMContentLoaded', initQuiz);
    </script>
</body>
</html>
