<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CEA201 Interactive Quiz - Computer Architecture</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .quiz-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .quiz-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .quiz-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .quiz-header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .score-summary {
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .score-item {
            text-align: center;
        }

        .score-number {
            font-size: 1.5em;
            font-weight: bold;
        }

        .score-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .quiz-content {
            padding: 40px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .question-item {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .question-item.answered {
            border-color: #28a745;
            background: #f8fff9;
        }

        .question-item.incorrect {
            border-color: #dc3545;
            background: #fff8f8;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .question-status {
            font-size: 1.2em;
        }

        .question-text {
            font-size: 1.1em;
            margin-bottom: 20px;
            color: #333;
            line-height: 1.5;
            font-weight: 500;
        }

        .options-container {
            margin-bottom: 15px;
        }

        .option-item {
            display: flex;
            align-items: center;
            background: white;
            margin: 8px 0;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option-item:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .option-item.selected {
            border-color: #667eea;
            background: #e3f2fd;
        }

        .option-item.correct {
            border-color: #28a745;
            background: #d4edda;
            color: #155724;
            font-weight: bold;
        }

        .option-item.incorrect {
            border-color: #dc3545;
            background: #f8d7da;
            color: #721c24;
        }

        .option-item.user-selected {
            border-color: #007bff;
            background: #cce7ff;
            font-weight: bold;
        }

        .option-item.user-incorrect {
            border-color: #dc3545;
            background: #f8d7da;
            color: #721c24;
            text-decoration: line-through;
        }

        .answer-indicator {
            margin-left: 10px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .correct-indicator {
            color: #28a745;
        }

        .incorrect-indicator {
            color: #dc3545;
        }

        .explanation {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .explanation.show {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .explanation h4 {
            color: #856404;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            font-size: 1em;
        }

        .explanation p {
            color: #533f04;
            line-height: 1.5;
            margin: 0;
        }

        .action-buttons {
            position: sticky;
            bottom: 0;
            background: white;
            padding: 20px 40px;
            border-top: 2px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .icon {
            margin-right: 8px;
        }

        /* Scrollbar styling */
        .quiz-content::-webkit-scrollbar {
            width: 8px;
        }

        .quiz-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .quiz-content::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .quiz-content::-webkit-scrollbar-thumb:hover {
            background: #5a6fd8;
        }
    </style>
</head>
<body>
    <div class="quiz-container">
        <div class="quiz-header">
            <h1>üñ•Ô∏è CEA201 Quiz</h1>
            <p>Computer Architecture & Organization - T·∫•t c·∫£ 50 c√¢u h·ªèi</p>
            <div class="score-summary">
                <div class="score-item">
                    <div class="score-number" id="totalQuestions">50</div>
                    <div class="score-label">T·ªïng c√¢u</div>
                </div>
                <div class="score-item">
                    <div class="score-number" id="answeredCount">0</div>
                    <div class="score-label">ƒê√£ tr·∫£ l·ªùi</div>
                </div>
                <div class="score-item">
                    <div class="score-number" id="correctCount">0</div>
                    <div class="score-label">ƒê√∫ng</div>
                </div>
                <div class="score-item">
                    <div class="score-number" id="scorePercentage">0%</div>
                    <div class="score-label">ƒêi·ªÉm s·ªë</div>
                </div>
            </div>
        </div>

        <div class="quiz-content" id="quizContent">
            <!-- Questions will be dynamically generated here -->
        </div>

        <div class="action-buttons">
            <button class="btn btn-secondary" onclick="resetQuiz()">
                üîÑ L√†m l·∫°i to√†n b·ªô
            </button>
            <div>
                <button class="btn btn-primary" onclick="showAllAnswers()">
                    üëÅÔ∏è Hi·ªán t·∫•t c·∫£ ƒë√°p √°n
                </button>
                <button class="btn btn-success" onclick="checkAllAnswers()">
                    ‚úÖ Ki·ªÉm tra k·∫øt qu·∫£
                </button>
            </div>
        </div>
    </div>

    <script>
        const questions = [
            {
                id: 1,
                question: "Choose the most four basic functions of a computer.",
                options: [
                    "Moving data, storing data, processing data, controlling.",
                    "Supporting operating system, accessing hard disks, supporting network connections, supporting HDMI ports.",
                    "Reading disks, accessing network resources.",
                    "Reading data from keyboard, printing data to monitor, allowing network connections."
                ],
                correct: 0,
                type: "single",
                explanation: "M√°y t√≠nh th·ª±c hi·ªán 4 ch·ª©c nƒÉng ch√≠nh: Di chuy·ªÉn d·ªØ li·ªáu (Moving data) gi·ªØa c√°c b·ªô ph·∫≠n, L∆∞u tr·ªØ d·ªØ li·ªáu (Storing data) trong b·ªô nh·ªõ RAM, ·ªï c·ª©ng, X·ª≠ l√Ω d·ªØ li·ªáu (Processing data) b·∫±ng CPU, ƒêi·ªÅu khi·ªÉn (Controlling) th√¥ng qua ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn CU."
            },
            {
                id: 2,
                question: "Refers to the operational units and their interconnections that realize the architectural specifications.",
                options: [
                    "Computer architecture",
                    "Computer function", 
                    "Computer organization",
                    "Instruction set architecture"
                ],
                correct: 2,
                type: "single",
                explanation: "Computer organization l√† c√°ch c√°c th√†nh ph·∫ßn k·∫øt n·ªëi v√† ho·∫°t ƒë·ªông ƒë·ªÉ th·ª±c hi·ªán c√°c ƒë·∫∑c t·∫£ ki·∫øn tr√∫c. Computer architecture l√† thi·∫øt k·∫ø t·ªïng th·ªÉ c·ªßa h·ªá th·ªëng, c√≤n Computer organization l√† vi·ªác tri·ªÉn khai c·ª• th·ªÉ."
            },
            {
                id: 3,
                question: "What is the most important function of the control unit (CU)?",
                options: [
                    "It manages the order of running instructions.",
                    "It will read and process data from main memory.",
                    "It directs the operation of the other CPU components.",
                    "It will read instructions from main memory then decoding them."
                ],
                correct: 2,
                type: "single",
                explanation: "CU l√† 'b·ªô n√£o' ƒëi·ªÅu khi·ªÉn m·ªçi ho·∫°t ƒë·ªông c·ªßa CPU, ƒë·∫£m b·∫£o c√°c l·ªánh ƒë∆∞·ª£c th·ª±c hi·ªán ƒë√∫ng tr√¨nh t·ª± v√† ƒëi·ªÅu ph·ªëi ho·∫°t ƒë·ªông c·ªßa t·∫•t c·∫£ c√°c th√†nh ph·∫ßn kh√°c trong CPU."
            },
            {
                id: 4,
                question: "The first generation of computers used _______ for digital logic elements and memory.",
                options: [
                    "Transistor",
                    "Integrated Circuits", 
                    "Large-scale integration",
                    "Vacuum Tubes"
                ],
                correct: 3,
                type: "single",
                explanation: "Th·∫ø h·ªá 1 (1940s-1950s) d√πng ƒë√®n ch√¢n kh√¥ng (Vacuum Tubes). Th·∫ø h·ªá 2 d√πng transistor, th·∫ø h·ªá 3 d√πng IC, th·∫ø h·ªá 4 d√πng LSI."
            },
            {
                id: 5,
                question: "What is Memory Address Register (MAR)?",
                options: [
                    "Contains a word to be stored in memory or sent to the I/O unit, or is used to receive a word from memory or from the I/O unit.",
                    "Employed to hold temporarily the righthand instruction from a word in memory.",
                    "Contains the address in memory of the word to be written from or read into the MBR.",
                    "Contains the address of the next instruction pair to be fetched from memory."
                ],
                correct: 2,
                type: "single",
                explanation: "MAR (Memory Address Register) ch·ª©a ƒë·ªãa ch·ªâ √¥ nh·ªõ c·∫ßn ƒë·ªçc ho·∫∑c ghi d·ªØ li·ªáu. N√≥ ho·∫°t ƒë·ªông c√πng v·ªõi MBR ƒë·ªÉ th·ª±c hi·ªán c√°c thao t√°c truy c·∫≠p b·ªô nh·ªõ."
            },
            {
                id: 6,
                question: "In the computer, what categories do external devices include? (Choose 3 answers)",
                options: [
                    "Human readable",
                    "Communication",
                    "Data Conversion",
                    "Machine readable"
                ],
                correct: [0, 1, 3],
                type: "multiple",
                explanation: "C√°c thi·∫øt b·ªã ngo·∫°i vi g·ªìm 3 nh√≥m ch√≠nh: Human readable (m√†n h√¨nh, b√†n ph√≠m, chu·ªôt), Communication (card m·∫°ng, modem), Machine readable (c·∫£m bi·∫øn, scanner). Data Conversion kh√¥ng ph·∫£i nh√≥m ch√≠nh."
            },
            {
                id: 7,
                question: "What is false about the von Neumann architecture?",
                options: [
                    "Data and instructions are stored in a single read-write memory.",
                    "The contents of this memory are addressable by location, without regard to the type of data contained there.",
                    "Execution occurs in a sequential fashion (unless explicitly modified) from one instruction to the next.",
                    "Data is stored in main memory and instructions are stored in cache memory."
                ],
                correct: 3,
                type: "single",
                explanation: "Von Neumann l∆∞u d·ªØ li·ªáu v√† l·ªánh chung m·ªôt b·ªô nh·ªõ. ƒê√°p √°n D n√≥i l·ªánh l∆∞u ·ªü cache, d·ªØ li·ªáu ·ªü RAM ‚Üí sai. ƒê√¢y l√† ƒë·∫∑c ƒëi·ªÉm c·ªßa Harvard architecture, kh√¥ng ph·∫£i von Neumann."
            },
            {
                id: 8,
                question: "What is the maximum addressable memory of a 32-bit microprocessor with 24-bit address?",
                options: [
                    "16 GB",
                    "16 MB",
                    "16 Gbits",
                    "16 Mbits"
                ],
                correct: 1,
                type: "single",
                explanation: "Dung l∆∞·ª£ng t·ªëi ƒëa = 2^s·ªë bit ƒë·ªãa ch·ªâ = 2^24 = 16MB. M·∫πo: Nh·ªõ c√¥ng th·ª©c 2^s·ªë bit ƒë·ªãa ch·ªâ ƒë·ªÉ t√≠nh!"
            },
            {
                id: 9,
                question: "_______ interprets the instructions in memory and causes them to be executed.",
                options: [
                    "Registers",
                    "CPU interconnection",
                    "Arithmetic and Logic Unit (ALU)",
                    "I/O Modules",
                    "Control Unit (CU)"
                ],
                correct: 4,
                type: "single",
                explanation: "CU ƒë·∫£m nh·∫≠n vi·ªác di·ªÖn gi·∫£i m√£ v√† th·ª±c thi l·ªánh. N·∫øu c√¢u h·ªèi n√≥i v·ªÅ ƒëi·ªÅu khi·ªÉn th·ª±c thi, ch·ªçn CU."
            },
            {
                id: 10,
                question: "What is the most important characteristic of the Synchronous Bus?",
                options: [
                    "Data is transmitted at the same time.",
                    "The occurrence of one event on a bus follows and depends on the occurrence of a previous event.",
                    "The occurrence of events on the bus is determined by a clock.",
                    "No common clock signal controlling operation."
                ],
                correct: 2,
                type: "single",
                explanation: "Bus ƒë·ªìng b·ªô (Synchronous Bus) ho·∫°t ƒë·ªông theo t√≠n hi·ªáu xung nh·ªãp (clock signal). N·∫øu c√≥ t·ª´ clock, ch·ªçn Synchronous Bus!"
            },
            {
                id: 11,
                question: "What is the correct order of memory access speed from fastest to slowest?",
                options: [
                    "Registers > Cache > RAM > SSD",
                    "Cache > Registers > RAM > SSD",
                    "Registers > Cache > SSD > RAM",
                    "Cache > Registers > SSD > RAM",
                    "All of the mentioned are wrong"
                ],
                correct: 0,
                type: "single",
                explanation: "Th·ª© t·ª± t·ªëc ƒë·ªô truy c·∫≠p b·ªô nh·ªõ t·ª´ nhanh ƒë·∫øn ch·∫≠m: Register > Cache > RAM > SSD. Thanh ghi (Register) nhanh nh·∫•t, SSD ch·∫≠m nh·∫•t."
            },
            {
                id: 12,
                question: "What is the special feature of Memory Cache?",
                options: [
                    "Allows faster access than DRAM memory",
                    "Memory cache is outboard storage memory",
                    "Allows faster access than CPU registers",
                    "Fixed memory - Read Only Memory",
                    "Has a larger capacity than HDD"
                ],
                correct: 0,
                type: "single",
                explanation: "Cache nhanh h∆°n RAM (DRAM), nh∆∞ng ch·∫≠m h∆°n Register. N·∫øu n√≥i v·ªÅ t·ªëc ƒë·ªô nhanh h∆°n DRAM, ch·ªçn Cache."
            },
            {
                id: 13,
                question: "In the direct mapping method from 256MB main memory with 512KB cache, what is the number of bits for the TAG element in the address?",
                options: [
                    "6",
                    "7",
                    "8",
                    "9"
                ],
                correct: 3,
                type: "single",
                explanation: "C√¥ng th·ª©c t√≠nh d·ª±a tr√™n s·ªë bit ƒë·ªãa ch·ªâ v√† k√≠ch th∆∞·ªõc cache. V·ªõi 256MB main memory v√† 512KB cache trong direct mapping, TAG c·∫ßn 9 bits."
            },
            {
                id: 14,
                question: "A byte addressable microprocessor has 24-bit address. What is maximum memory capacity?",
                options: [
                    "4 MegaByte",
                    "8 MegaByte",
                    "16 MegaByte",
                    "32 MegaByte"
                ],
                correct: 2,
                type: "single",
                explanation: "Dung l∆∞·ª£ng t·ªëi ƒëa = 2^24 = 16MB. Byte addressable c√≥ nghƒ©a l√† m·ªói ƒë·ªãa ch·ªâ tr·ªè ƒë·∫øn 1 byte."
            },
            {
                id: 15,
                question: "In error correcting code (single ECC), how many bits are used to correct one bit in 8-bit data?",
                options: [
                    "4",
                    "5",
                    "6",
                    "7"
                ],
                correct: 0,
                type: "single",
                explanation: "ECC s·ª≠ d·ª•ng 4 bit ƒë·ªÉ s·ª≠a l·ªói 1-bit trong d·ªØ li·ªáu 8-bit. ƒê√¢y l√† c√¥ng th·ª©c chu·∫©n c·ªßa Single Error Correction."
            },
            {
                id: 16,
                question: "What is correct about increasing performance and endurance?",
                options: [
                    "Hard Disk - DRAM - NAND Flash - SRAM",
                    "Hard Disk - NAND Flash - DRAM - SRAM",
                    "NAND Flash - Hard Disk - SRAM - DRAM",
                    "Hard Disk - DRAM - SRAM - NAND Flash"
                ],
                correct: 1,
                type: "single",
                explanation: "Th·ª© t·ª± hi·ªáu nƒÉng v√† ƒë·ªô b·ªÅn t·ª´ th·∫•p ƒë·∫øn cao: Hard Disk ‚Üí NAND Flash ‚Üí DRAM ‚Üí SRAM"
            },
            {
                id: 17,
                question: "With the hard disk data layout, the set of all the tracks in the same relative position on the platter is called",
                options: [
                    "Cylinder",
                    "Tracks",
                    "Inter-track gap",
                    "Sector"
                ],
                correct: 0,
                type: "single",
                explanation: "Cylinder l√† t·∫≠p h·ª£p t·∫•t c·∫£ c√°c track ·ªü c√πng v·ªã tr√≠ t∆∞∆°ng ƒë·ªëi tr√™n c√°c ƒëƒ©a. ƒê√¢y l√† kh√°i ni·ªám quan tr·ªçng trong c·∫•u tr√∫c ·ªï c·ª©ng."
            },
            {
                id: 18,
                question: "Which RAID level uses striping technique with a minimum of 3 disks and provides fault tolerance through the use of parity bit?",
                options: [
                    "RAID 0",
                    "RAID 1",
                    "RAID 2",
                    "RAID 3"
                ],
                correct: 3,
                type: "single",
                explanation: "RAID 3 s·ª≠ d·ª•ng striping v·ªõi t·ªëi thi·ªÉu 3 ƒëƒ©a v√† cung c·∫•p kh·∫£ nƒÉng ch·ªãu l·ªói th√¥ng qua parity bit. RAID 0 kh√¥ng c√≥ fault tolerance, RAID 1 l√† mirroring."
            },
            {
                id: 19,
                question: "In terms of performance, what is the main advantage of a solid state drive over a magnetic disk?",
                options: [
                    "A solid state drive has faster access time, lower latency, and higher reliability",
                    "A solid state drive has larger capacity, lower power consumption, and lower cost",
                    "A solid state drive has better compatibility, longer lifespan, and higher security",
                    "A solid state drive has none of the mentioned advantages over a magnetic disk"
                ],
                correct: 0,
                type: "single",
                explanation: "SSD c√≥ t·ªëc ƒë·ªô truy xu·∫•t nhanh h∆°n, ƒë·ªô tr·ªÖ th·∫•p h∆°n v√† ƒë·ªô tin c·∫≠y cao h∆°n so v·ªõi HDD t·ª´ t√≠nh."
            },
            {
                id: 20,
                question: "Consider the expression: NOT(A + B) = ? Apply DeMorgan's Theorem to replace at \"?\"",
                options: [
                    "NOT A AND NOT B",
                    "NOT A OR NOT B",
                    "NOT A AND B",
                    "A OR NOT B"
                ],
                correct: 0,
                type: "single",
                explanation: "ƒê·ªãnh l√Ω DeMorgan: NOT(A + B) = NOT A AND NOT B. Ph·ªß ƒë·ªãnh c·ªßa OR l√† AND c·ªßa c√°c ph·ªß ƒë·ªãnh."
            },
            {
                id: 21,
                question: "An I/O module must recognize one unique address for each peripheral it controls. (2) I/O channels are commonly seen on microcomputers, whereas I/O controllers are used on mainframes. The statement 1 is __ and 2 is __:",
                options: [
                    "true, false",
                    "true, true",
                    "false, true",
                    "false, false"
                ],
                correct: 0,
                type: "single",
                explanation: "(1) ‚úÖ ƒê√∫ng: M·ªói I/O module c·∫ßn nh·∫≠n bi·∫øt ƒë·ªãa ch·ªâ duy nh·∫•t c·ªßa t·ª´ng thi·∫øt b·ªã ngo·∫°i vi m√† n√≥ ƒëi·ªÅu khi·ªÉn. (2) ‚ùå Sai: I/O channels th∆∞·ªùng xu·∫•t hi·ªán tr√™n mainframe, c√≤n I/O controllers ph·ªï bi·∫øn trong microcomputers."
            },
            {
                id: 22,
                question: "What is an interrupt vector?",
                options: [
                    "Part of memory which contains the addresses of interrupt handlers",
                    "A signal an I/O device sends to CPU",
                    "A signal an I/O software sends to CPU",
                    "None of the mentioned"
                ],
                correct: 0,
                type: "single",
                explanation: "Interrupt vector l√† m·ªôt b·∫£ng trong b·ªô nh·ªõ, ch·ª©a ƒë·ªãa ch·ªâ c·ªßa c√°c interrupt handlers (tr√¨nh x·ª≠ l√Ω ng·∫Øt). Khi c√≥ ng·∫Øt x·∫£y ra, CPU s·∫Ω tra c·ª©u interrupt vector ƒë·ªÉ x√°c ƒë·ªãnh tr√¨nh x·ª≠ l√Ω t∆∞∆°ng ·ª©ng."
            },
            {
                id: 23,
                question: "If the operation involves reference to an operand in memory or available via I/O, then determine the address of the operand.",
                options: [
                    "Operand fetch",
                    "Data operation",
                    "Operand store",
                    "Operand address calculation"
                ],
                correct: 3,
                type: "single",
                explanation: "N·∫øu m·ªôt to√°n h·∫°ng n·∫±m trong b·ªô nh·ªõ ho·∫∑c c√≥ s·∫µn qua I/O, tr∆∞·ªõc ti√™n h·ªá th·ªëng c·∫ßn t√≠nh to√°n ƒë·ªãa ch·ªâ c·ªßa n√≥. ƒê√¢y ch√≠nh l√† b∆∞·ªõc Operand address calculation ‚Äì x√°c ƒë·ªãnh v·ªã tr√≠ c·ªßa to√°n h·∫°ng tr∆∞·ªõc khi truy xu·∫•t."
            },
            {
                id: 24,
                question: "What role does an Application Programming Interface (API) play in software development?",
                options: [
                    "It allows program access to hardware resources using high-level language libraries",
                    "It defines low-level machine instructions",
                    "It provides a standard for binary portability",
                    "It manages system resources for the operating system and machine language instructions"
                ],
                correct: 0,
                type: "single",
                explanation: "API l√† giao di·ªán l·∫≠p tr√¨nh ·ª©ng d·ª•ng, cho ph√©p ph·∫ßn m·ªÅm truy c·∫≠p v√†o t√†i nguy√™n ph·∫ßn c·ª©ng th√¥ng qua c√°c th∆∞ vi·ªán ng√¥n ng·ªØ b·∫≠c cao. API gi√∫p l·∫≠p tr√¨nh vi√™n kh√¥ng c·∫ßn can thi·ªáp tr·ª±c ti·∫øp v√†o ph·∫ßn c·ª©ng m√† v·∫´n c√≥ th·ªÉ thao t√°c v·ªõi n√≥ m·ªôt c√°ch d·ªÖ d√†ng."
            },
            {
                id: 25,
                question: "What is the initial state of a process when it is admitted by the high-level scheduler, but not yet ready to execute?",
                options: [
                    "New",
                    "Ready",
                    "Running",
                    "Halted"
                ],
                correct: 0,
                type: "single",
                explanation: "Khi m·ªôt ti·∫øn tr√¨nh v·ª´a ƒë∆∞·ª£c t·∫°o b·ªüi high-level scheduler, nh∆∞ng ch∆∞a s·∫µn s√†ng ch·∫°y ngay l·∫≠p t·ª©c, n√≥ s·∫Ω ·ªü tr·∫°ng th√°i New. Sau khi ƒë·ªß ƒëi·ªÅu ki·ªán, n√≥ s·∫Ω chuy·ªÉn sang Ready, ƒë·ª£i CPU x·ª≠ l√Ω."
            },
            {
                id: 26,
                question: "Which of the following statements is incorrect about Translation Look-aside Buffer (TLB)?",
                options: [
                    "The use of TLB eliminates the need for keeping a page table in memory",
                    "TLB only maintains a subset of the entries stored in the full memory-based page table",
                    "When there is a TLB miss the system needs to access the page table",
                    "A translation lookaside buffer (TLB) is a memory cache that stores the recent translations of virtual memory to physical memory"
                ],
                correct: 0,
                type: "single",
                explanation: "‚ùå TLB ch·ªâ l√† m·ªôt b·ªô nh·ªõ cache gi√∫p gi·∫£m b·ªõt th·ªùi gian truy c·∫≠p v√†o b·∫£ng trang (page table). Tuy nhi√™n, b·∫£ng trang v·∫´n c·∫ßn thi·∫øt v√† kh√¥ng th·ªÉ b·ªã lo·∫°i b·ªè khi s·ª≠ d·ª•ng TLB."
            },
            {
                id: 27,
                question: "How does Boolean algebra contribute to the design of digital circuits?",
                options: [
                    "It simplifies the implementation of desired functions",
                    "It helps in the analysis of economic data",
                    "It facilitates the design of analog circuits",
                    "It is primarily used for chemical engineering and physical engineering"
                ],
                correct: 0,
                type: "single",
                explanation: "üîß ƒê·∫°i s·ªë Boole gi√∫p gi·∫£m thi·ªÉu c√°c ph√©p to√°n logic ph·ª©c t·∫°p v√† bi·ªÉu di·ªÖn ch√∫ng d∆∞·ªõi d·∫°ng ƒë∆°n gi·∫£n h∆°n ƒë·ªÉ thi·∫øt k·∫ø m·∫°ch s·ªë."
            },
            {
                id: 28,
                question: "When both inputs are 1, what is the result of a NAND gate?",
                options: [
                    "0",
                    "1",
                    "2",
                    "Undefined",
                    "#NA"
                ],
                correct: 0,
                type: "single",
                explanation: "üî¥ ƒê·ªëi v·ªõi c·ªïng NAND, n·∫øu c·∫£ hai ƒë·∫ßu v√†o l√† 1, ƒë·∫ßu ra s·∫Ω l√† 0. ‚ö†Ô∏è C·∫ßn nh·ªõ r·∫±ng NAND l√† ph·ªß ƒë·ªãnh c·ªßa AND, do ƒë√≥ khi ƒë·∫ßu v√†o l√† 1 v√† 1, k·∫øt qu·∫£ l√† 0."
            },
            {
                id: 29,
                question: "What is the result of 10100101 XOR 11001001?",
                options: [
                    "11101101",
                    "10000001",
                    "01101100",
                    "10101100"
                ],
                correct: 2,
                type: "single",
                explanation: "üî¢ Ph√©p XOR so s√°nh t·ª´ng bit c·ªßa hai s·ªë nh·ªã ph√¢n, v√† n·∫øu c√°c bit t∆∞∆°ng ·ª©ng kh√°c nhau, k·∫øt qu·∫£ l√† 1, n·∫øu gi·ªëng nhau, k·∫øt qu·∫£ l√† 0. üí° H√£y nh·ªõ r·∫±ng XOR (Exclusive OR) tr·∫£ v·ªÅ 1 ch·ªâ khi hai bit ƒë·ªëi di·ªán kh√°c nhau."
            },
            {
                id: 30,
                question: "What is the result of left rotating 10110101 by 2 bits?",
                options: [
                    "01101011",
                    "10101101",
                    "01101101",
                    "11010110",
                    "11010100"
                ],
                correct: 3,
                type: "single",
                explanation: "üîÑ Qu√° tr√¨nh quay tr√°i (left rotation) s·∫Ω di chuy·ªÉn c√°c bit sang tr√°i v√† ƒë∆∞a c√°c bit b·ªã di chuy·ªÉn ra ngo√†i v√†o ph√≠a b√™n ph·∫£i. üîß ƒê·ªÉ quay tr√°i, b·∫°n c√≥ th·ªÉ h√¨nh dung vi·ªác di chuy·ªÉn bit qua c√°c v·ªã tr√≠ v√† ƒë∆∞a c√°c bit ngo√†i v√†o cu·ªëi chu·ªói."
            },
            {
                id: 31,
                question: "Why is it essential to use symbolic representation of machine instructions?",
                options: [
                    "It makes machine instructions more human-readable and understandable",
                    "It reduces the overall complexity of computer systems and user programs",
                    "It minimizes the need for memory storage for the user programs",
                    "It enables fastest execution of high-level language instructions"
                ],
                correct: 0,
                type: "single",
                explanation: "üìñ Bi·ªÉu di·ªÖn d·∫°ng k√Ω hi·ªáu gi√∫p cho l·∫≠p tr√¨nh vi√™n d·ªÖ d√†ng ƒë·ªçc v√† hi·ªÉu m√£ m√°y, tr√°nh ph·∫£i l√†m vi·ªác v·ªõi m√£ nh·ªã ph√¢n tr·ª±c ti·∫øp. üí° C√°c k√Ω hi·ªáu gi√∫p tƒÉng hi·ªáu qu·∫£ l·∫≠p tr√¨nh v√† gi·∫£m b·ªõt kh√≥ khƒÉn trong vi·ªác ph√°t tri·ªÉn ph·∫ßn m·ªÅm."
            },
            {
                id: 32,
                question: "What are the most important general categories of data that machine instructions operate on?",
                options: [
                    "Addresses, numbers, characters, and logical data",
                    "Text, images, and audio",
                    "Variables, functions, and arrays",
                    "Instructions, control signals, and registers"
                ],
                correct: 0,
                type: "single",
                explanation: "üî¢ M√£ m√°y th∆∞·ªùng ho·∫°t ƒë·ªông tr√™n c√°c lo·∫°i d·ªØ li·ªáu nh∆∞ ƒë·ªãa ch·ªâ (addresses), s·ªë (numbers), k√Ω t·ª± (characters), v√† d·ªØ li·ªáu logic (logical data). üíª H√£y li√™n k·∫øt c√°c kh√°i ni·ªám c∆° b·∫£n nh∆∞ s·ªë v√† k√Ω t·ª± v·ªõi c√°c t√°c v·ª• m√°y t√≠nh ƒë·ªÉ d·ªÖ d√†ng nh·ªõ."
            },
            {
                id: 33,
                question: "What is a branch instruction?",
                options: [
                    "The instructions that are used to divide a program into multiple subprograms",
                    "The instructions that have as one of its operands the address of the next instruction to be executed",
                    "The instructions that are used to pause the program",
                    "The instructions that are used to return to the beginning of the program"
                ],
                correct: 1,
                type: "single",
                explanation: "üîÄ C√¢u l·ªánh nh√°nh ch·ª©a ƒë·ªãa ch·ªâ c·ªßa l·ªánh ti·∫øp theo, gi√∫p thay ƒë·ªïi lu·ªìng th·ª±c thi c·ªßa ch∆∞∆°ng tr√¨nh. üöÄ Nh·ªõ r·∫±ng c√°c l·ªánh nh√°nh l√† c∆° b·∫£n cho c√°c v√≤ng l·∫∑p v√† c·∫•u tr√∫c ƒëi·ªÅu ki·ªán trong ch∆∞∆°ng tr√¨nh."
            },
            {
                id: 34,
                question: "The effective address of Register indirect addressing mode is:",
                options: [
                    "EA = R",
                    "EA = (R)",
                    "EA = (R)+A",
                    "EA = (R)+(A)"
                ],
                correct: 1,
                type: "single",
                explanation: "üìç Trong ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ gi√°n ti·∫øp, ƒë·ªãa ch·ªâ hi·ªáu qu·∫£ l√† gi√° tr·ªã trong thanh ghi R, kh√¥ng ph·∫£i gi√° tr·ªã trong √¥ nh·ªõ m√† thanh ghi ch·ªâ ƒë·∫øn. üß† Khi l√†m vi·ªác v·ªõi ch·∫ø ƒë·ªô gi√°n ti·∫øp, h√£y ch√∫ √Ω ƒë·∫øn vi·ªác ch·ªâ m·ª•c v√† gi√° tr·ªã trong c√°c thanh ghi."
            },
            {
                id: 35,
                question: "Which of the following PDP series computers is known for its use of 12-bit instructions and a single general-purpose register, the accumulator?",
                options: [
                    "PDP-8",
                    "PDP-10",
                    "PDP-11",
                    "PDP-6"
                ],
                correct: 0,
                type: "single",
                explanation: "PDP-8 n·ªïi ti·∫øng v·ªõi l·ªánh 12-bit v√† s·ª≠ d·ª•ng m·ªôt thanh ghi ƒëa nƒÉng duy nh·∫•t l√† accumulator. ƒê√¢y l√† m·ªôt trong nh·ªØng m√°y t√≠nh mini quan tr·ªçng trong l·ªãch s·ª≠."
            },
            {
                id: 36,
                question: "What is the main difference between x86 and ARM instruction formats?",
                options: [
                    "x86 instructions are variable in length, while ARM instructions are fixed",
                    "x86 instructions are fixed in length, while ARM instructions are variable",
                    "Both x86 and ARM instructions are fixed in length",
                    "Both x86 and ARM instructions are variable in length"
                ],
                correct: 0,
                type: "single",
                explanation: "x86 c√≥ l·ªánh ƒë·ªô d√†i thay ƒë·ªïi (variable length), trong khi ARM c√≥ l·ªánh ƒë·ªô d√†i c·ªë ƒë·ªãnh (fixed length). ƒê√¢y l√† m·ªôt trong nh·ªØng kh√°c bi·ªát c∆° b·∫£n gi·ªØa hai ki·∫øn tr√∫c."
            },
            {
                id: 37,
                question: "What is the primary purpose of the \"Fetch instruction\" phase in the operation of a processor?",
                options: [
                    "To read an instruction from memory",
                    "To interpret the instruction",
                    "To perform arithmetic operations on data",
                    "To write data to memory"
                ],
                correct: 0,
                type: "single",
                explanation: "Giai ƒëo·∫°n 'Fetch instruction' üì• c√≥ m·ª•c ƒë√≠ch ch√≠nh l√† ƒë·ªçc l·ªánh t·ª´ b·ªô nh·ªõ v√†o CPU ƒë·ªÉ chu·∫©n b·ªã cho vi·ªác th·ª±c thi."
            },
            {
                id: 38,
                question: "Control and status registers are used by which entities to control the operation of the processor?",
                options: [
                    "Privileged, operating system programs",
                    "Machine or assembly language programmers",
                    "External I/O devices",
                    "Main memory modules"
                ],
                correct: 0,
                type: "single",
                explanation: "C√°c thanh ghi ƒëi·ªÅu khi·ªÉn v√† tr·∫°ng th√°i üõ°Ô∏è ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi c√°c ch∆∞∆°ng tr√¨nh h·ªá ƒëi·ªÅu h√†nh c√≥ ƒë·∫∑c quy·ªÅn (privileged OS programs) ƒë·ªÉ ƒëi·ªÅu khi·ªÉn ho·∫°t ƒë·ªông c·ªßa b·ªô x·ª≠ l√Ω."
            },
            {
                id: 39,
                question: "What is the significance of the program counter (PC) in the fetch phase of the instruction cycle?",
                options: [
                    "The program counter (PC) is not used in the fetch phase, and its role is limited to tracking the number of instructions executed by the CPU",
                    "The program counter (PC) in the fetch phase holds the memory address of the next instruction to be fetched and executed",
                    "The program counter (PC) is responsible for executing instructions and has no specific role during the fetch phase",
                    "The program counter (PC) is only relevant in multi-core processors and does not contribute to the fetch phase of the instruction cycle in single-core systems"
                ],
                correct: 1,
                type: "single",
                explanation: "Program Counter (PC) üéØ trong giai ƒëo·∫°n fetch gi·ªØ ƒë·ªãa ch·ªâ b·ªô nh·ªõ c·ªßa l·ªánh ti·∫øp theo c·∫ßn ƒë∆∞·ª£c l·∫•y v√† th·ª±c thi. ƒê√¢y l√† vai tr√≤ quan tr·ªçng ƒë·ªÉ duy tr√¨ tr√¨nh t·ª± th·ª±c hi·ªán ch∆∞∆°ng tr√¨nh."
            },
            {
                id: 40,
                question: "Which of the following statements is correct in the context of Instruction Pipelining?",
                options: [
                    "Instruction Pipelining reduces the efficiency of instruction execution by introducing delays and dependencies between instructions",
                    "Instruction Pipelining is only effective for specific types of instructions and has no impact on the overall efficiency of instruction execution",
                    "Instruction Pipelining enhances efficiency by enabling simultaneous execution of multiple instructions in different stages, boosting overall throughput",
                    "Instruction Pipelining improves efficiency by processing multiple instructions simultaneously, reducing execution time. However, it can face challenges like hazards, introducing delays and impacting overall performance"
                ],
                correct: 3,
                type: "single",
                explanation: "Instruction Pipelining ‚ö° c·∫£i thi·ªán hi·ªáu qu·∫£ b·∫±ng c√°ch x·ª≠ l√Ω nhi·ªÅu l·ªánh ƒë·ªìng th·ªùi, gi·∫£m th·ªùi gian th·ª±c thi. Tuy nhi√™n, n√≥ c√≥ th·ªÉ g·∫∑p c√°c th√°ch th·ª©c nh∆∞ hazards, g√¢y ra ƒë·ªô tr·ªÖ v√† ·∫£nh h∆∞·ªüng ƒë·∫øn hi·ªáu su·∫•t t·ªïng th·ªÉ."
            },
            {
                id: 41,
                question: "Which statement is incorrect about RISC and CISC architecture?",
                options: [
                    "CISC architecture is more convenient for programmers than RISC architecture.",
                    "CISC architecture has more operands in an instruction compared to RISC architecture.",
                    "CISC architecture has a more flexible instruction set than RISC architecture.",
                    "CISC architecture requires more general-purpose registers than RISC architecture."
                ],
                correct: 3,
                type: "single",
                explanation: "‚ùå CISC th·ª±c t·∫ø c·∫ßn √≠t thanh ghi ƒëa nƒÉng h∆°n RISC. RISC c·∫ßn nhi·ªÅu thanh ghi h∆°n ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu t·∫°m th·ªùi do c√°c l·ªánh ƒë∆°n gi·∫£n h∆°n."
            },
            {
                id: 42,
                question: "What is one of the advantages of using a register file in computer architecture?",
                options: [
                    "Reduction in memory accesses, saving time",
                    "More efficient use of space due to dynamic adaptation",
                    "Efficient handling of both local and global variables",
                    "Easier management of cache residency"
                ],
                correct: 0,
                type: "single",
                explanation: "Register file gi√∫p gi·∫£m s·ªë l·∫ßn truy c·∫≠p b·ªô nh·ªõ, ti·∫øt ki·ªám th·ªùi gian th·ª±c thi. ƒê√¢y l√† l·ª£i √≠ch ch√≠nh v√¨ thanh ghi c√≥ t·ªëc ƒë·ªô truy c·∫≠p nhanh nh·∫•t."
            },
            {
                id: 43,
                question: "How does pipelining in a RISC architecture handle branch instruction?",
                options: [
                    "By using NOOP instructions inserted by the compiler or assembler",
                    "By eliminating branch instructions from the instruction stream",
                    "By executing branch instructions in a separate pipeline",
                    "By delaying all instructions until branch instructions are executed"
                ],
                correct: 0,
                type: "single",
                explanation: "Pipelining trong RISC x·ª≠ l√Ω l·ªánh nh√°nh b·∫±ng c√°ch s·ª≠ d·ª•ng l·ªánh NOOP (No Operation) ƒë∆∞·ª£c ch√®n b·ªüi compiler ho·∫∑c assembler ƒë·ªÉ tr√°nh hazards."
            },
            {
                id: 44,
                question: "What is the benefit of using a superscalar organization over a scalar organization?",
                options: [
                    "It increases the instruction throughput and improves the performance",
                    "It reduces the power consumption and the heat dissipation",
                    "It simplifies the instruction set and the compiler design",
                    "All of the mentioned",
                    "None of the mentioned"
                ],
                correct: 0,
                type: "single",
                explanation: "Superscalar organization tƒÉng throughput l·ªánh v√† c·∫£i thi·ªán hi·ªáu su·∫•t b·∫±ng c√°ch th·ª±c thi nhi·ªÅu l·ªánh ƒë·ªìng th·ªùi trong m·ªôt chu k·ª≥ clock."
            },
            {
                id: 45,
                question: "What does the term \"instruction-level parallelism\" refer to in computer architecture?",
                options: [
                    "The degree to which instructions in a program can be executed in parallel",
                    "The number of processor cores in a multi-core CPU with multiple resources",
                    "The complexity of the instruction set architecture",
                    "The length of an instruction cycle with high-level programming language"
                ],
                correct: 0,
                type: "single",
                explanation: "Instruction-level parallelism ƒë·ªÅ c·∫≠p ƒë·∫øn m·ª©c ƒë·ªô m√† c√°c l·ªánh trong ch∆∞∆°ng tr√¨nh c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c thi song song. ƒê√¢y l√† kh√°i ni·ªám quan tr·ªçng trong t·ªëi ∆∞u h√≥a hi·ªáu su·∫•t."
            },
            {
                id: 46,
                question: "\"Multiple processors share a single memory or pool of memory by means of a shared bus or other interconnection mechanism; a distinguishing feature is that the memory access time to any region of memory is approximately the same for each processor.\" Which concept does the statement belong to?",
                options: [
                    "Symmetric multiprocessor (SMP)",
                    "Nonuniform memory access (NUMA)",
                    "Cluster",
                    "Single instruction, multiple data (SIMD)"
                ],
                correct: 0,
                type: "single",
                explanation: "M√¥ t·∫£ n√†y thu·ªôc v·ªÅ Symmetric Multiprocessor (SMP), n∆°i nhi·ªÅu b·ªô x·ª≠ l√Ω chia s·∫ª b·ªô nh·ªõ chung v·ªõi th·ªùi gian truy c·∫≠p t∆∞∆°ng ƒë∆∞∆°ng cho t·∫•t c·∫£ processor."
            },
            {
                id: 47,
                question: "Which write technique ensures that all write operations are made to main memory as well as to the cache, ensuring that main memory is always valid?",
                options: [
                    "Write through",
                    "Write back",
                    "Write around",
                    "No write allocate"
                ],
                correct: 0,
                type: "single",
                explanation: "Write through ƒë·∫£m b·∫£o t·∫•t c·∫£ thao t√°c ghi ƒë∆∞·ª£c th·ª±c hi·ªán v√†o c·∫£ b·ªô nh·ªõ ch√≠nh v√† cache, ƒë·∫£m b·∫£o b·ªô nh·ªõ ch√≠nh lu√¥n c√≥ d·ªØ li·ªáu h·ª£p l·ªá."
            },
            {
                id: 48,
                question: "What is one advantage of Nonuniform Memory Access (NUMA) over Uniform Memory Access (UMA)?",
                options: [
                    "NUMA provides each processor with its own local memory, reducing memory access times",
                    "NUMA allows all processors to access the same memory location simultaneously",
                    "NUMA is easier to implement than UMA",
                    "NUMA provides limited memory capacity"
                ],
                correct: 0,
                type: "single",
                explanation: "NUMA cung c·∫•p cho m·ªói processor b·ªô nh·ªõ c·ª•c b·ªô ri√™ng, gi·∫£m th·ªùi gian truy c·∫≠p b·ªô nh·ªõ so v·ªõi UMA. ƒê√¢y l√† l·ª£i th·∫ø ch√≠nh c·ªßa ki·∫øn tr√∫c NUMA."
            },
            {
                id: 49,
                question: "Following Amdahl's law for multiprocessors, if only 10% of the code is inherently serial (f = 0.9), running the program on a multicore system with 4 processors, the performance gain (speedup factor) would be:",
                options: [
                    "307%",
                    "297%",
                    "317%",
                    "327%"
                ],
                correct: 2,
                type: "single",
                explanation: "Theo ƒë·ªãnh lu·∫≠t Amdahl, v·ªõi f = 0.9 (90% song song) v√† 4 processors, speedup = 1/(0.1 + 0.9/4) = 1/0.325 ‚âà 3.17 = 317%."
            },
            {
                id: 50,
                question: "What is the most common mapping technique used in cache memory in modern computers?",
                options: [
                    "Direct Mapping",
                    "Fully Associative",
                    "Set Associative",
                    "None of the mentioned"
                ],
                correct: 2,
                type: "single",
                explanation: "Set Associative l√† k·ªπ thu·∫≠t √°nh x·∫° ph·ªï bi·∫øn nh·∫•t trong cache memory hi·ªán ƒë·∫°i v√¨ n√≥ c√¢n b·∫±ng gi·ªØa hi·ªáu su·∫•t v√† ƒë·ªô ph·ª©c t·∫°p c·ªßa ph·∫ßn c·ª©ng."
            }
        ];

        let userAnswers = {};
        let showingAnswers = false;

        function initQuiz() {
            renderAllQuestions();
            updateScoreSummary();
        }

        function renderAllQuestions() {
            const quizContent = document.getElementById('quizContent');
            
            quizContent.innerHTML = questions.map(question => `
                <div class="question-item" id="question-${question.id}">
                    <div class="question-header">
                        <div class="question-number">C√¢u ${question.id}</div>
                        <div class="question-status" id="status-${question.id}">‚ùì</div>
                    </div>
                    
                    <div class="question-text">${question.question}</div>
                    
                    <div class="options-container">
                        ${question.options.map((option, index) => `
                            <div class="option-item" onclick="selectOption(${question.id}, ${index})">
                                ${question.type === 'multiple' ? 
                                    `<input type="checkbox" class="option-checkbox" id="q${question.id}-opt${index}" onchange="selectOption(${question.id}, ${index})">` :
                                    `<input type="radio" name="q${question.id}" class="option-radio" id="q${question.id}-opt${index}" onchange="selectOption(${question.id}, ${index})">`
                                }
                                <label class="option-text" for="q${question.id}-opt${index}">
                                    ${String.fromCharCode(65 + index)}. ${option}
                                </label>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="explanation" id="explanation-${question.id}">
                        <h4><span class="icon">üí°</span>Gi·∫£i th√≠ch:</h4>
                        <p>${question.explanation}</p>
                    </div>
                </div>
            `).join('');
        }

        function selectOption(questionId, optionIndex) {
            const question = questions.find(q => q.id === questionId);
            const questionElement = document.getElementById(`question-${questionId}`);
            const optionElement = document.getElementById(`q${questionId}-opt${optionIndex}`);
            
            if (showingAnswers) return; // Prevent changes when answers are shown
            
            if (question.type === 'multiple') {
                // Handle multiple choice
                if (!userAnswers[questionId]) {
                    userAnswers[questionId] = [];
                }
                
                if (optionElement.checked) {
                    if (!userAnswers[questionId].includes(optionIndex)) {
                        userAnswers[questionId].push(optionIndex);
                    }
                } else {
                    userAnswers[questionId] = userAnswers[questionId].filter(idx => idx !== optionIndex);
                }
                
                // Check if user has selected the correct number of answers for multiple choice
                const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                if (userAnswers[questionId] && userAnswers[questionId].length === correctAnswers.length) {
                    showQuestionFeedback(questionId);
                } else {
                    hideQuestionFeedback(questionId);
                }
            } else {
                // Handle single choice
                userAnswers[questionId] = optionIndex;
                // Show feedback immediately for single choice
                showQuestionFeedback(questionId);
            }
            
            updateQuestionStatus(questionId);
            updateScoreSummary();
        }

        function showQuestionFeedback(questionId) {
            const question = questions.find(q => q.id === questionId);
            const explanationElement = document.getElementById(`explanation-${questionId}`);
            const isCorrect = checkAnswer(questionId);
            
            // Show explanation
            explanationElement.classList.add('show');
            
            // Update option styling to show correct/incorrect
            const optionElements = document.querySelectorAll(`[id^="q${questionId}-opt"]`);
            optionElements.forEach((element, index) => {
                const optionContainer = element.parentElement;
                optionContainer.classList.remove('correct', 'incorrect', 'user-selected', 'user-incorrect');
                
                // Remove existing indicators
                const existingIndicator = optionContainer.querySelector('.answer-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
                
                const userAnswer = userAnswers[questionId];
                const isUserSelection = question.type === 'multiple' ? 
                    (userAnswer && userAnswer.includes(index)) : 
                    (userAnswer === index);
                
                if (question.type === 'multiple') {
                    const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                    
                    if (correctAnswers.includes(index)) {
                        // This is a correct answer
                        optionContainer.classList.add('correct');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator correct-indicator';
                        indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng' : '‚úì ƒê√°p √°n ƒë√∫ng';
                        optionContainer.appendChild(indicator);
                    } else if (isUserSelection) {
                        // User selected wrong answer
                        optionContainer.classList.add('user-incorrect');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator incorrect-indicator';
                        indicator.textContent = '‚úó Sai';
                        optionContainer.appendChild(indicator);
                    }
                } else {
                    if (index === question.correct) {
                        // This is the correct answer
                        optionContainer.classList.add('correct');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator correct-indicator';
                        indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng' : '‚úì ƒê√°p √°n ƒë√∫ng';
                        optionContainer.appendChild(indicator);
                    } else if (isUserSelection) {
                        // User selected wrong answer
                        optionContainer.classList.add('user-incorrect');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator incorrect-indicator';
                        indicator.textContent = '‚úó Sai';
                        optionContainer.appendChild(indicator);
                    }
                }
            });
        }

        function hideQuestionFeedback(questionId) {
            const explanationElement = document.getElementById(`explanation-${questionId}`);
            explanationElement.classList.remove('show');
            
            // Remove feedback styling from options
            const optionElements = document.querySelectorAll(`[id^="q${questionId}-opt"]`);
            optionElements.forEach((element, index) => {
                const optionContainer = element.parentElement;
                optionContainer.classList.remove('correct', 'incorrect', 'user-selected', 'user-incorrect');
                
                // Remove existing indicators
                const existingIndicator = optionContainer.querySelector('.answer-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
            });
        }

        function updateQuestionStatus(questionId) {
            const question = questions.find(q => q.id === questionId);
            const statusElement = document.getElementById(`status-${questionId}`);
            const questionElement = document.getElementById(`question-${questionId}`);
            
            // Check if question is properly answered
            let isAnswered = false;
            if (question.type === 'multiple') {
                const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                isAnswered = userAnswers[questionId] && userAnswers[questionId].length === correctAnswers.length;
            } else {
                isAnswered = userAnswers[questionId] !== undefined;
            }
            
            if (isAnswered) {
                if (showingAnswers || hasQuestionFeedback(questionId)) {
                    const isCorrect = checkAnswer(questionId);
                    statusElement.textContent = isCorrect ? '‚úÖ' : '‚ùå';
                    questionElement.className = `question-item ${isCorrect ? 'answered' : 'incorrect'}`;
                } else {
                    statusElement.textContent = '‚úèÔ∏è';
                    questionElement.className = 'question-item answered';
                }
            } else {
                statusElement.textContent = '‚ùì';
                questionElement.className = 'question-item';
            }
        }

        function hasQuestionFeedback(questionId) {
            const explanationElement = document.getElementById(`explanation-${questionId}`);
            return explanationElement.classList.contains('show');
        }

        function checkAnswer(questionId) {
            const question = questions.find(q => q.id === questionId);
            const userAnswer = userAnswers[questionId];
            
            if (question.type === 'multiple') {
                if (!userAnswer || userAnswer.length === 0) return false;
                const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                return userAnswer.length === correctAnswers.length && 
                       userAnswer.every(ans => correctAnswers.includes(ans));
            } else {
                return userAnswer === question.correct;
            }
        }

        function updateScoreSummary() {
            const answeredCount = Object.keys(userAnswers).filter(qId => {
                const question = questions.find(q => q.id == qId);
                const answer = userAnswers[qId];
                return answer !== undefined && 
                       (question.type === 'single' || (question.type === 'multiple' && answer.length > 0));
            }).length;
            
            const correctCount = Object.keys(userAnswers).filter(qId => checkAnswer(parseInt(qId))).length;
            const percentage = answeredCount > 0 ? Math.round((correctCount / questions.length) * 100) : 0;
            
            document.getElementById('answeredCount').textContent = answeredCount;
            document.getElementById('correctCount').textContent = correctCount;
            document.getElementById('scorePercentage').textContent = percentage + '%';
        }

        function showAllAnswers() {
            showingAnswers = true;
            
            questions.forEach(question => {
                const explanationElement = document.getElementById(`explanation-${question.id}`);
                explanationElement.classList.add('show');
                
                // Highlight correct answers only
                const optionElements = document.querySelectorAll(`[id^="q${question.id}-opt"]`);
                optionElements.forEach((element, index) => {
                    const optionContainer = element.parentElement;
                    optionContainer.classList.remove('correct', 'incorrect', 'selected', 'user-selected', 'user-incorrect');
                    
                    // Remove existing indicators
                    const existingIndicator = optionContainer.querySelector('.answer-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }
                    
                    if (question.type === 'multiple') {
                        const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                        if (correctAnswers.includes(index)) {
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = '‚úì ƒê√∫ng';
                            optionContainer.appendChild(indicator);
                        }
                    } else {
                        if (index === question.correct) {
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = '‚úì ƒê√°p √°n ƒë√∫ng';
                            optionContainer.appendChild(indicator);
                        }
                    }
                    
                    // Disable further interactions
                    element.disabled = true;
                });
                
                updateQuestionStatus(question.id);
            });
            
            updateScoreSummary();
        }

        function checkAllAnswers() {
            showingAnswers = true;
            
            questions.forEach(question => {
                const explanationElement = document.getElementById(`explanation-${question.id}`);
                explanationElement.classList.add('show');
                
                // Show user answers vs correct answers
                const optionElements = document.querySelectorAll(`[id^="q${question.id}-opt"]`);
                optionElements.forEach((element, index) => {
                    const optionContainer = element.parentElement;
                    optionContainer.classList.remove('correct', 'incorrect', 'selected', 'user-selected', 'user-incorrect');
                    
                    // Remove existing indicators
                    const existingIndicator = optionContainer.querySelector('.answer-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }
                    
                    const userAnswer = userAnswers[question.id];
                    const isUserSelection = question.type === 'multiple' ? 
                        (userAnswer && userAnswer.includes(index)) : 
                        (userAnswer === index);
                    
                    if (question.type === 'multiple') {
                        const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                        
                        if (correctAnswers.includes(index)) {
                            // This is a correct answer
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng - B·∫°n ƒë√£ ch·ªçn' : '‚úì ƒê√°p √°n ƒë√∫ng';
                            optionContainer.appendChild(indicator);
                        } else if (isUserSelection) {
                            // User selected wrong answer
                            optionContainer.classList.add('user-incorrect');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator incorrect-indicator';
                            indicator.textContent = '‚úó Sai - B·∫°n ƒë√£ ch·ªçn';
                            optionContainer.appendChild(indicator);
                        }
                    } else {
                        if (index === question.correct) {
                            // This is the correct answer
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng - B·∫°n ƒë√£ ch·ªçn' : '‚úì ƒê√°p √°n ƒë√∫ng';
                            optionContainer.appendChild(indicator);
                        } else if (isUserSelection) {
                            // User selected wrong answer
                            optionContainer.classList.add('user-incorrect');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator incorrect-indicator';
                            indicator.textContent = '‚úó Sai - B·∫°n ƒë√£ ch·ªçn';
                            optionContainer.appendChild(indicator);
                        }
                    }
                    
                    // Disable further interactions
                    element.disabled = true;
                });
                
                updateQuestionStatus(question.id);
            });
            
            updateScoreSummary();
        }

        function resetQuiz() {
            userAnswers = {};
            showingAnswers = false;
            
            // Reset all form elements
            document.querySelectorAll('input[type="radio"], input[type="checkbox"]').forEach(input => {
                input.checked = false;
                input.disabled = false;
            });
            
            // Hide all explanations and feedback
            questions.forEach(question => {
                hideQuestionFeedback(question.id);
            });
            
            // Reset all option styling and remove indicators
            document.querySelectorAll('.option-item').forEach(option => {
                option.classList.remove('correct', 'incorrect', 'selected', 'user-selected', 'user-incorrect');
                const indicator = option.querySelector('.answer-indicator');
                if (indicator) {
                    indicator.remove();
                }
            });
            
            // Update all question statuses
            questions.forEach(question => {
                updateQuestionStatus(question.id);
            });
            
            updateScoreSummary();
        }

        // Initialize quiz when page loads
        document.addEventListener('DOMContentLoaded', initQuiz);
    </script>
</body>
</html>
